<?php

declare(strict_types=1);

namespace kuaukutsu\cache;

use Closure;
use yii\caching\CacheInterface;
use yii\caching\TagDependency;

/**
 * Базовый класс: позволяет типизировать подход к кешированию данных получаемых из запроса на основе модели.
 *
 * @example:
 * Model cache
 * ```php
 *  $model = $this->db->cache(
 *      fn() => Model::findOne(['one' => IDENTITY, 'two' => IDENTITY2, 'three' => IDENTITY3]),
 *      86400,
 *      $this->cache->generateTagDependency(IDENTITY, IDENTITY2, IDENTITY3)
 *  );
 * ```
 * Value cache
 * ```php
 * $cache->getCacheInterface()->getOrSet(
 *      $cache->generateKey(1,'key'),
 *      fn() => 1, // Closure query
 *      $cache->getDuration(),
 *      $cache->generateTagDependency(1,'tag')
 * )
 * ```
 *
 * Short
 * ```php
 * $value = $cache->getOrSet(
 *      fn() => 11,
 *      [11, 'tag']
 * ):
 * ```
 *
 * Cache invalidate:
 * ```
 * $this->cache->invalidate(IDENTITY, IDENTITY2, IDENTITY3);
 * ```
 *
 * Cache flush:
 * ```
 * $this->cache->flush();
 * ```
 */
abstract class CacheDecoratorBase implements CacheDecorator
{
    private CacheInterface $cache;

    /**
     * @param CacheInterface $cache
     */
    public function __construct(CacheInterface $cache)
    {
        $this->cache = $cache;
    }

    /**
     * Note: If the given key is a string containing alphanumeric characters only and no more than 32 characters,
     * then the key will be returned prefixed with [[keyPrefix]]. Otherwise, a normalized key
     * is generated by serializing the given key, applying MD5 hashing, and prefixing with [[keyPrefix]].
     * @see \yii\caching\CacheInterface::buildKey
     *
     * @param array<array-key, scalar> $conditions
     * @return string
     */
    abstract protected function generateUniqueKey(array $conditions): string;

    abstract protected function generateShareKey(): string;

    public function getDuration(): int
    {
        return 3600;
    }

    /**
     * @param Closure $callable
     * @param scalar[] $conditions
     * @return mixed
     */
    final public function getOrSet(Closure $callable, array $conditions)
    {
        return $this->cache->getOrSet(
            $this->generateKey(...$conditions),
            $callable,
            $this->getDuration(),
            $this->generateTagDependency(...$conditions)
        );
    }

    /**
     * @param string $key a key identifying the value to be cached. This can be a simple string.
     * @return mixed|false
     */
    final public function get(string $key)
    {
        return $this->cache->get($this->generateKey($key));
    }

    /**
     * @param string $key a key identifying the value to be cached. This can be a simple string.
     * @param mixed $value the value to be cached
     * @return bool
     */
    final public function set(string $key, $value): bool
    {
        return $this->cache->set(
            $this->generateKey($key),
            $value,
            $this->getDuration(),
            $this->generateTagDependency($key)
        );
    }

    final public function delete(string $key): void
    {
        $this->cache->delete($this->generateKey($key));
    }

    final public function getCacheInterface(): CacheInterface
    {
        return $this->cache;
    }

    /**
     * Генерация ключа для кеша на основе входящих аргументов
     *
     * @param scalar ...$args
     * @return string
     */
    final public function generateKey(...$args): string
    {
        return $this->generateUniqueKey($args);
    }

    /**
     * Генерация зависимости для кеша на основе TagDependency
     *
     * @param scalar ...$args
     * @return TagDependency
     */
    final public function generateTagDependency(...$args): TagDependency
    {
        return new TagDependency(['tags' => [$this->generateUniqueKey($args), $this->generateShareKey()]]);
    }

    /**
     * Инвалидация ключа по параметрам
     *
     * @param scalar ...$args
     */
    final public function invalidate(...$args): void
    {
        TagDependency::invalidate($this->cache, $this->generateUniqueKey($args));
    }

    /**
     * Полная инвалидация всех ключей для рабочей модели.
     */
    final public function flush(): void
    {
        TagDependency::invalidate($this->cache, $this->generateShareKey());
    }
}
